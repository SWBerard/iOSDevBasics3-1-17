package com.example.project;

import android.content.Context;
import android.graphics.Paint;
import android.graphics.PorterDuff;
import android.graphics.PorterDuffXfermode;
import android.graphics.Matrix;
import android.graphics.PointF;
import android.graphics.RectF;
import android.graphics.Shader;
import android.graphics.LinearGradient;
import android.graphics.RadialGradient;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Path;
import android.graphics.DashPathEffect;
import android.text.Layout;
import android.text.StaticLayout;
import android.text.TextPaint;
import android.graphics.Typeface;
import java.util.Stack;



/**
 * Created by AuthorName on 2/13/17.
 * Copyright Â© 2017 CompanyName. All rights reserved.
 *
 * Generated by PaintCode
 * http://www.paintcodeapp.com
 *
 * @author AuthorName
 */
public class MyStyleKit {
    // Context Property Declaration
    
    public static Context context = null;
    
    // Colors
    
    public static int color = Color.argb(255, 0, 38, 255);
    public static int color2 = PaintCodeColor.colorByChangingSaturation(MyStyleKit.color, 0.1f);
    public static int color3 = PaintCodeColor.colorByChangingAlpha(MyStyleKit.color, 153);
    public static int color4 = PaintCodeColor.colorByApplyingHighlight(MyStyleKit.color, 0.5f);
    
    
    // Resizing Behavior
    
    public enum ResizingBehavior {
        AspectFit, //!< The content is proportionally resized to fit into the target rectangle.
        AspectFill, //!< The content is proportionally resized to completely fill the target rectangle.
        Stretch, //!< The content is stretched to match the entire target rectangle.
        Center, //!< The content is centered in the target rectangle, but it is NOT resized.
    }
    
    // Canvas Drawings
    
    // Text Bubbles
    
    
    public static void drawTextBubble(Canvas canvas, RectF frame) {
        // General Declarations
        Paint paint;
        
        // Group
        {
            RectF group = new RectF(
                frame.left + 6f,
                frame.top + 4f,
                frame.right - 8f,
                frame.bottom - 7f);
            
            // Oval 2
            RectF oval2Rect = new RectF(
                group.left + (float) Math.floor(group.width() * 0.06048f - 0.15f) + 0.65f,
                group.top + (float) Math.floor(group.height() * 0.11328f + 0.4f) + 0.1f,
                group.left + (float) Math.floor(group.width() * 0.39392f + 0.17f) + 0.33f,
                group.top + (float) Math.floor(group.height() * 0.51903f - 0.37f) + 0.87f);
            Path oval2Path = new Path();
            oval2Path.moveTo(group.left + group.width() * 0.07785f, group.top + group.height() * 0.51903f);
            oval2Path.cubicTo(group.left + group.width() * 0.06654f, group.top + group.height() * 0.49031f, group.left + group.width() * 0.06048f, group.top + group.height() * 0.45996f, group.left + group.width() * 0.06048f, group.top + group.height() * 0.42857f);
            oval2Path.cubicTo(group.left + group.width() * 0.06048f, group.top + group.height() * 0.27675f, group.left + group.width() * 0.20222f, group.top + group.height() * 0.14921f, group.left + group.width() * 0.39392f, group.top + group.height() * 0.11328f);
            
            paint = new Paint(Paint.ANTI_ALIAS_FLAG);
            paint.setStrokeWidth(4f);
            paint.setStrokeCap(Paint.Cap.ROUND);
            paint.setStrokeMiter(10f);
            canvas.save();
            paint.setStyle(Paint.Style.STROKE);
            paint.setColor(Color.LTGRAY);
            canvas.drawPath(oval2Path, paint);
            canvas.restore();
            
            // Bezier 2
            RectF bezier2Rect = new RectF(
                group.left,
                group.top,
                group.left + (float) Math.floor(group.width() + 0.5f),
                group.top + (float) Math.floor(group.height() + 0.5f));
            Path bezier2Path = new Path();
            bezier2Path.moveTo(group.left + group.width(), group.top + group.height() * 0.43651f);
            bezier2Path.cubicTo(group.left + group.width(), group.top + group.height() * 0.67758f, group.left + group.width() * 0.77614f, group.top + group.height() * 0.87302f, group.left + group.width() * 0.5f, group.top + group.height() * 0.87302f);
            bezier2Path.cubicTo(group.left + group.width() * 0.41353f, group.top + group.height() * 0.87302f, group.left + group.width() * 0.33219f, group.top + group.height() * 0.85385f, group.left + group.width() * 0.26124f, group.top + group.height() * 0.82013f);
            bezier2Path.cubicTo(group.left + group.width() * 0.18824f, group.top + group.height() * 0.92589f, group.left + group.width() * 0.05645f, group.top + group.height(), group.left + group.width() * 0.05645f, group.top + group.height());
            bezier2Path.cubicTo(group.left + group.width() * 0.05645f, group.top + group.height(), group.left + group.width() * 0.1126f, group.top + group.height() * 0.86738f, group.left + group.width() * 0.13119f, group.top + group.height() * 0.73125f);
            bezier2Path.cubicTo(group.left + group.width() * 0.04972f, group.top + group.height() * 0.65359f, group.left, group.top + group.height() * 0.55012f, group.left, group.top + group.height() * 0.43651f);
            bezier2Path.cubicTo(group.left, group.top + group.height() * 0.24922f, group.left + group.width() * 0.13511f, group.top + group.height() * 0.08948f, group.left + group.width() * 0.32488f, group.top + group.height() * 0.02752f);
            bezier2Path.cubicTo(group.left + group.width() * 0.37938f, group.top + group.height() * 0.00973f, group.left + group.width() * 0.43839f, group.top, group.left + group.width() * 0.5f, group.top);
            bezier2Path.cubicTo(group.left + group.width() * 0.77614f, group.top, group.left + group.width(), group.top + group.height() * 0.19543f, group.left + group.width(), group.top + group.height() * 0.43651f);
            bezier2Path.close();
            
            paint = new Paint(Paint.ANTI_ALIAS_FLAG);
            paint.setStrokeWidth(4f);
            paint.setStrokeMiter(10f);
            canvas.save();
            paint.setStyle(Paint.Style.STROKE);
            paint.setColor(Color.LTGRAY);
            canvas.drawPath(bezier2Path, paint);
            canvas.restore();
        }
    }
    
    
    public static void drawRectTextBubble(Canvas canvas, RectF frame) {
        // General Declarations
        Paint paint;
        
        // Frame 2
        RectF frame2 = new RectF(
            frame.left + (float) Math.floor((frame.width() - 22f) * 0.50794f + 0.5f),
            frame.bottom - 17f,
            frame.left + (float) Math.floor((frame.width() - 22f) * 0.50794f + 0.5f) + 22f,
            frame.bottom);
        
        // Bezier
        RectF bezierRect = new RectF(
            frame2.left - 30f,
            frame2.top - 30f,
            frame2.left + 51f,
            frame2.top + 12.57f);
        Path bezierPath = new Path();
        bezierPath.moveTo(frame.right - 5.35f, frame.top + 3.33f);
        bezierPath.lineTo(frame.right - 5.16f, frame.top + 3.37f);
        bezierPath.cubicTo(frame.right - 3.86f, frame.top + 3.85f, frame.right - 2.85f, frame.top + 4.86f, frame.right - 2.37f, frame.top + 6.16f);
        bezierPath.cubicTo(frame.right - 2f, frame.top + 7.34f, frame.right - 2f, frame.top + 8.44f, frame.right - 2f, frame.top + 10.64f);
        bezierPath.lineTo(frame.right - 2f, frame.bottom - 21.14f);
        bezierPath.cubicTo(frame.right - 2f, frame.bottom - 18.94f, frame.right - 2f, frame.bottom - 17.84f, frame.right - 2.33f, frame.bottom - 16.85f);
        bezierPath.lineTo(frame.right - 2.37f, frame.bottom - 16.66f);
        bezierPath.cubicTo(frame.right - 2.85f, frame.bottom - 15.36f, frame.right - 3.86f, frame.bottom - 14.35f, frame.right - 5.16f, frame.bottom - 13.87f);
        bezierPath.cubicTo(frame.right - 6.34f, frame.bottom - 13.5f, frame.right - 7.44f, frame.bottom - 13.5f, frame.right - 9.64f, frame.bottom - 13.5f);
        bezierPath.lineTo(frame2.left + 20.32f, frame2.bottom - 13.5f);
        bezierPath.cubicTo(frame2.left + 15.86f, frame2.bottom - 9.04f, frame2.left + 11.25f, frame2.bottom - 4.43f, frame2.left + 11.25f, frame2.bottom - 4.43f);
        bezierPath.cubicTo(frame2.left + 11.25f, frame2.bottom - 4.43f, frame2.left + 6.64f, frame2.bottom - 9.04f, frame2.left + 2.18f, frame2.bottom - 13.5f);
        bezierPath.lineTo(frame.left + 9.64f, frame.bottom - 13.5f);
        bezierPath.cubicTo(frame.left + 7.44f, frame.bottom - 13.5f, frame.left + 6.34f, frame.bottom - 13.5f, frame.left + 5.35f, frame.bottom - 13.83f);
        bezierPath.lineTo(frame.left + 5.16f, frame.bottom - 13.87f);
        bezierPath.cubicTo(frame.left + 3.86f, frame.bottom - 14.35f, frame.left + 2.85f, frame.bottom - 15.36f, frame.left + 2.37f, frame.bottom - 16.66f);
        bezierPath.cubicTo(frame.left + 2f, frame.bottom - 17.84f, frame.left + 2f, frame.bottom - 18.94f, frame.left + 2f, frame.bottom - 21.14f);
        bezierPath.lineTo(frame.left + 2f, frame.top + 10.64f);
        bezierPath.cubicTo(frame.left + 2f, frame.top + 8.44f, frame.left + 2f, frame.top + 7.34f, frame.left + 2.33f, frame.top + 6.35f);
        bezierPath.lineTo(frame.left + 2.37f, frame.top + 6.16f);
        bezierPath.cubicTo(frame.left + 2.85f, frame.top + 4.86f, frame.left + 3.86f, frame.top + 3.85f, frame.left + 5.16f, frame.top + 3.37f);
        bezierPath.cubicTo(frame.left + 6.34f, frame.top + 3f, frame.left + 7.44f, frame.top + 3f, frame.left + 9.64f, frame.top + 3f);
        bezierPath.lineTo(frame.right - 9.64f, frame.top + 3f);
        bezierPath.cubicTo(frame.right - 7.44f, frame.top + 3f, frame.right - 6.34f, frame.top + 3f, frame.right - 5.35f, frame.top + 3.33f);
        bezierPath.close();
        
        paint = new Paint(Paint.ANTI_ALIAS_FLAG);
        paint.setStyle(Paint.Style.FILL);
        paint.setColor(MyStyleKit.color2);
        canvas.drawPath(bezierPath, paint);
        
        paint = new Paint(Paint.ANTI_ALIAS_FLAG);
        paint.setStrokeWidth(3f);
        paint.setStrokeMiter(10f);
        canvas.save();
        paint.setStyle(Paint.Style.STROKE);
        paint.setColor(MyStyleKit.color);
        canvas.drawPath(bezierPath, paint);
        canvas.restore();
    }
    
    // Buttons
    
    
    public static void drawSelectButton(Canvas canvas, RectF frame, boolean pressed) {
        // General Declarations
        Paint paint;
        
        // Rectangle
        RectF rectangleRect = new RectF(
            frame.left + 5f,
            frame.top + 4f,
            frame.right - 5f,
            frame.bottom - 5f);
        Path rectanglePath = new Path();
        rectanglePath.addRoundRect(rectangleRect, 10f, 10f, Path.Direction.CW);
        
        paint = new Paint(Paint.ANTI_ALIAS_FLAG);
        paint.setStyle(Paint.Style.FILL);
        paint.setColor(MyStyleKit.color2);
        canvas.drawPath(rectanglePath, paint);
        
        paint = new Paint(Paint.ANTI_ALIAS_FLAG);
        paint.setStrokeWidth(3f);
        paint.setStrokeMiter(10f);
        canvas.save();
        paint.setStyle(Paint.Style.STROKE);
        paint.setColor(MyStyleKit.color);
        canvas.drawPath(rectanglePath, paint);
        canvas.restore();
        TextPaint rectangleTextPaint = new TextPaint();
        rectangleTextPaint.setColor(MyStyleKit.color);
        rectangleTextPaint.setTypeface(Typeface.createFromAsset(context.getAssets(), "HelveticaNeue.dfont"));
        rectangleTextPaint.setTextSize(17f);
        StaticLayout rectangleStaticLayout = new StaticLayout("Button", rectangleTextPaint, (int) rectangleRect.width(), Layout.Alignment.ALIGN_CENTER, 1f, 0f, false);
        canvas.save();
        canvas.clipRect(rectangleRect);
        canvas.translate(rectangleRect.left, rectangleRect.top + (rectangleRect.height() - rectangleStaticLayout.getHeight()) / 2f);
        rectangleStaticLayout.draw(canvas);
        canvas.restore();
        
        // Rectangle 2
        if (pressed) {
            RectF rectangle2Rect = new RectF(
                frame.left + 5f,
                frame.top + 4.5f,
                frame.right - 5f,
                frame.bottom - 4.5f);
            Path rectangle2Path = new Path();
            rectangle2Path.addRoundRect(rectangle2Rect, 10f, 10f, Path.Direction.CW);
            
            paint = new Paint(Paint.ANTI_ALIAS_FLAG);
            paint.setStyle(Paint.Style.FILL);
            paint.setColor(MyStyleKit.color3);
            canvas.drawPath(rectangle2Path, paint);
        }
    }
    
    // Graphs
    
    
    public static void drawCircleGraph(Canvas canvas, RectF frame, float percent) {
        // General Declarations
        Stack<Matrix> currentTransformation = new Stack<Matrix>();
        currentTransformation.push(new Matrix());
        Paint paint;
        
        // Local Colors
        int color7 = Color.argb(255, 0, 0, 0);
        int eFLightBlue = Color.argb(255, 61, 212, 243);
        int eFLightGreen = Color.argb(255, 136, 242, 61);
        
        // Local Gradients
        PaintCodeGradient gradient = new PaintCodeGradient(new int[]{eFLightBlue, PaintCodeColor.colorByBlendingColors(eFLightBlue, 0.5f, eFLightGreen), eFLightGreen}, new float[]{0f, 0.55f, 1f});
        
        // Local Variables
        float percentCalculation = percent / 100f * 360f;
        
        // Group
        {
            RectF group = new RectF(
                frame.left + 23f,
                frame.top + 18f,
                frame.right - 19f,
                frame.bottom - 21f);
            
            // Oval
            RectF ovalRect = new RectF(
                group.left,
                group.top,
                group.left + (float) Math.floor(group.width() + 0.5f),
                group.top + (float) Math.floor(group.height() + 0.5f));
            Path ovalPath = new Path();
            ovalPath.moveTo(group.left + group.width(), group.top + group.height() * 0.5f);
            ovalPath.cubicTo(group.left + group.width(), group.top + group.height() * 0.77614f, group.left + group.width() * 0.77614f, group.top + group.height(), group.left + group.width() * 0.5f, group.top + group.height());
            ovalPath.cubicTo(group.left + group.width() * 0.22386f, group.top + group.height(), group.left, group.top + group.height() * 0.77614f, group.left, group.top + group.height() * 0.5f);
            ovalPath.cubicTo(group.left, group.top + group.height() * 0.22386f, group.left + group.width() * 0.22386f, group.top, group.left + group.width() * 0.5f, group.top);
            ovalPath.cubicTo(group.left + group.width() * 0.77614f, group.top, group.left + group.width(), group.top + group.height() * 0.22386f, group.left + group.width(), group.top + group.height() * 0.5f);
            ovalPath.close();
            
            paint = new Paint(Paint.ANTI_ALIAS_FLAG);
            Matrix ovalPathGradientTransform = new Matrix();
            ovalPathGradientTransform.postRotate(25f);
            ovalPath.transform(ovalPathGradientTransform);
            RectF ovalPathBounds = new RectF();
            ovalPath.computeBounds(ovalPathBounds, true);
            Matrix ovalPathGradientInvertedTransform = new Matrix();
            ovalPathGradientTransform.invert(ovalPathGradientInvertedTransform);
            ovalPath.transform(ovalPathGradientInvertedTransform);
            float[] ovalPathGradientPoints = new float[]{ovalPathBounds.left, ovalPathBounds.centerY(), ovalPathBounds.right, ovalPathBounds.centerY()};
            ovalPathGradientInvertedTransform.mapPoints(ovalPathGradientPoints);
            paint.setStyle(Paint.Style.FILL);
            paint.setShader(gradient.linearGradient(ovalPathGradientPoints[0], ovalPathGradientPoints[1], ovalPathGradientPoints[2], ovalPathGradientPoints[3]));
            canvas.drawPath(ovalPath, paint);
        }
        
        // Group 2
        {
            
            paint = new Paint(Paint.ANTI_ALIAS_FLAG);
            paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));
            canvas.saveLayer(null, paint, Canvas.ALL_SAVE_FLAG);
            {
                canvas.save();
                RectF group2 = new RectF(98f, 57f, 205f, 164f);
                // Oval 2
                canvas.save();
                canvas.translate(group2.left + 53.5f, group2.bottom - 53.5f);
                canvas.rotate(-90f);
                currentTransformation.peek().postRotate(-90f);
                RectF oval2Rect = new RectF(-53.5f, -53.5f, 53.5f, 53.5f);
                Path oval2Path = new Path();
                oval2Path.moveTo(53.5f, 0f);
                oval2Path.cubicTo(53.5f, 29.55f, 29.55f, 53.5f, 0f, 53.5f);
                oval2Path.cubicTo(-29.55f, 53.5f, -53.5f, 29.55f, -53.5f, 0f);
                oval2Path.cubicTo(-53.5f, -29.55f, -29.55f, -53.5f, 0f, -53.5f);
                oval2Path.cubicTo(29.55f, -53.5f, 53.5f, -29.55f, 53.5f, 0f);
                oval2Path.close();
                
                paint = new Paint(Paint.ANTI_ALIAS_FLAG);
                paint.setStrokeWidth(10f);
                paint.setStrokeCap(Paint.Cap.ROUND);
                paint.setStrokeMiter(10f);
                paint.setPathEffect(new DashPathEffect(new float[]{percentCalculation, 716f}, 0f));
                canvas.save();
                paint.setStyle(Paint.Style.STROKE);
                paint.setColor(color7);
                canvas.drawPath(oval2Path, paint);
                canvas.restore();
                canvas.restore();
                canvas.restore();
            }
            canvas.restore();
        }
    }
    
    
    public static void drawCircleGraph2(Canvas canvas, RectF frame, float percent) {
        // General Declarations
        Stack<Matrix> currentTransformation = new Stack<Matrix>();
        currentTransformation.push(new Matrix());
        Paint paint;
        
        // Local Variables
        float percentCalculation = percent / 100f * 360f;
        float largeCircleCalculation = percentCalculation * 2f;
        
        // Oval
        canvas.save();
        canvas.translate(frame.left + 120f, frame.top + 120f);
        canvas.rotate(-90f);
        currentTransformation.peek().postRotate(-90f);
        RectF ovalRect = new RectF(-111f, -111f, 111f, 111f);
        Path ovalPath = new Path();
        ovalPath.addOval(ovalRect, Path.Direction.CW);
        
        paint = new Paint(Paint.ANTI_ALIAS_FLAG);
        paint.setStrokeWidth(10f);
        paint.setStrokeCap(Paint.Cap.ROUND);
        paint.setStrokeMiter(10f);
        paint.setPathEffect(new DashPathEffect(new float[]{largeCircleCalculation, 716f}, 0f));
        canvas.save();
        paint.setStyle(Paint.Style.STROKE);
        paint.setColor(Color.BLACK);
        canvas.drawPath(ovalPath, paint);
        canvas.restore();
        canvas.restore();
    }
    
    // Tab
    
    public static void drawCanvas2(Canvas canvas) {
        MyStyleKit.drawCanvas2(canvas, new RectF(0f, 0f, 240f, 120f), ResizingBehavior.AspectFit);
    }
    
    public static void drawCanvas2(Canvas canvas, RectF targetFrame, ResizingBehavior resizing) {
        // Resize to Target Frame
        canvas.save();
        RectF resizedFrame = MyStyleKit.resizingBehaviorApply(resizing, new RectF(0f, 0f, 240f, 120f), targetFrame);
        canvas.translate(new PointF(resizedFrame.left, resizedFrame.top).x, new PointF(resizedFrame.left, resizedFrame.top).y);
        canvas.scale(resizedFrame.width() / 240f, resizedFrame.height() / 120f);
        
        // Empty.
        
        canvas.restore();
    }
    
    
    // Resizing Behavior
    
    public static RectF resizingBehaviorApply(ResizingBehavior behavior, RectF rect, RectF target) {
        if (rect.equals(target) || target == null) {
            return rect;
        }
        
        if (behavior == ResizingBehavior.Stretch) {
            return target;
        }
        
        PointF ratio = new PointF();
        ratio.x = Math.abs(target.width() / rect.width());
        ratio.y = Math.abs(target.height() / rect.height());
        
        float scale = 0f;
        
        switch (behavior) {
            case AspectFit: {
                scale = Math.min(ratio.x, ratio.y);
                break;
            }
            case AspectFill: {
                scale = Math.max(ratio.x, ratio.y);
                break;
            }
            case Center: {
                scale = 1f;
                break;
            }
        }
        
        PointF newSize = new PointF(Math.abs(rect.width() * scale), Math.abs(rect.height() * scale));
        RectF result = new RectF(target.centerX(), target.centerY(), target.centerX(), target.centerY());
        result.inset(-newSize.x / 2f, -newSize.y / 2f);
        return result;
    }
    
    
}

 class PaintCodeColor extends Color {
    private static float[] ColorToHSV(int originalColor) {
        float hsv[] = new float[3];
        RGBToHSV(red(originalColor), green(originalColor), blue(originalColor), hsv);
        return hsv;
    }
    
    public static int colorByChangingHue(int originalColor, float newHue) {
        float hsv[] = ColorToHSV(originalColor);
        hsv[0] = newHue;
        return HSVToColor(alpha(originalColor), hsv);
    }
    
    public static int colorByChangingSaturation(int originalColor, float newSaturation) {
        float hsv[] = ColorToHSV(originalColor);
        hsv[1] = newSaturation;
        return HSVToColor(alpha(originalColor), hsv);
    }
    
    public static int colorByChangingValue(int originalColor, float newValue) {
        float hsv[] = ColorToHSV(originalColor);
        hsv[2] = newValue;
        return HSVToColor(alpha(originalColor), hsv);
    }
    
    public static float hue(int color) {
        return ColorToHSV(color)[0];
    }
    
    public static float saturation(int color) {
        return ColorToHSV(color)[1];
    }
    
    public static float brightness(int color) {
        return ColorToHSV(color)[2];
    }
    
    public static int colorByChangingAlpha(int color, int newAlpha) {
        return argb(newAlpha, red(color), green(color), blue(color));
    }
    
    public static int colorByBlendingColors(int c1, float ratio, int c2) {
        return argb((int) ((1f - ratio) * alpha(c1) + ratio * alpha(c2)),
            (int) ((1f - ratio) * red(c1) + ratio * red(c2)),
            (int) ((1f - ratio) * green(c1) + ratio * green(c2)),
            (int) ((1f - ratio) * blue(c1) + ratio * blue(c2)));
    }
    
    public static int colorByApplyingHighlight(int color, float ratio) {
        return colorByBlendingColors(color, ratio, colorByChangingAlpha(WHITE, alpha(color)));
    }
    
    public static int colorByApplyingShadow(int color, float ratio) {
        return colorByBlendingColors(color, ratio, colorByChangingAlpha(BLACK, alpha(color)));
    }
}

 class PaintCodeGradient {
    public int[] colors;
    public float[] positions;
    
    public PaintCodeGradient(int[] colors, float[] positions) {
        int steps = colors.length;
        if (positions == null)
        {
            positions = new float[steps];
            for (int i = 0; i < steps; i++)
                positions[i] = (float)i / (steps-1);
        }
    
        this.colors = colors;
        this.positions = positions;
    }
    
    public RadialGradient radialGradient(float startX, float startY, float startRadius, float endX, float endY, float endRadius)
    {
        float centerX = startX;
        float centerY = startY;
    
        if (startRadius > endRadius) {
            centerX = endX;
            centerY = endY;
        }
    
        PaintCodeGradient gradient = this.gradientForRadial(startRadius, endRadius);
        return new RadialGradient(centerX, centerY, Math.max(startRadius, endRadius), gradient.colors, gradient.positions, Shader.TileMode.CLAMP);
    }
    
    public LinearGradient linearGradient(float x0, float y0, float x1, float y1)
    {
        return new LinearGradient(x0, y0, x1, y1, this.colors, this.positions, Shader.TileMode.CLAMP);
    }
    
    private PaintCodeGradient gradientForRadial(float startRadius, float endRadius)
    {
        int[] colors;
        float[] positions;
    
        float ratio = startRadius / endRadius;
        int steps = this.colors.length;
    
        if (startRadius > endRadius)
        {
            colors = new int[steps];
            positions = new float[steps];
    
            for (int i = 0; i < steps; i++)
            {
                colors[i] = this.colors[steps - i - 1];
                positions[i] = 1 - this.positions[steps - i - 1];
                ratio = endRadius / startRadius;
            }
        }
        else
        {
            colors = this.colors;
            positions = this.positions.clone();
        }
    
        for (int i = 0; i < steps; i++)
            positions[i] = positions[i] * (1-ratio) + ratio;
    
        return new PaintCodeGradient(colors, positions);
    }
}